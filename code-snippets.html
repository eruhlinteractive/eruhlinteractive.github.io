<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Snippets - ERuhl Interactive</title>
    <link rel="stylesheet" type="text/css" href="./styles/code-snippets.css">
    <link rel="icon" href="./res/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="./res/favicon.ico" type="image/x-icon">
    <script src="./src/code-snippets.js" type="module"></script>
</head>
<body>
    <button id="top-button" title="Back to top">Back to Top</button> 
    <main class="container px-6 pt-6">
        <web-nav></web-nav>
        <h1 class="is-size-1 py-2">Code Snippets</h1>
        
        <p> Below are some snippets of code I have written throughout various projects. If you have any questions, feel free to contact me
            using the 'contact me' link above.
        </p>
        <br>

        <h2 class="is-size-2 py-2">Languages</h2>
        <ul class="px-5 is-size-3">
            <li>
                <a href="#cpp-code">- C++</a>
            </li>
            <li>
                <a href="#csharp-code">- C#</a>
            </li>
            <li>
                <a href="#gdscript-code">- GD Script</a>
            </li>
        </ul>
        <br>
        <hr>
        <br>
        <!--C++ Code-->
        <h3 class="is-size-3">C++</h3>
        <div class="section" id="cpp-code">
            <p>
                Below is the main file of an entity class I created that combines the functionality of the <a href="https://www.reactphysics3d.com/">React3D physics engine </a>and DirectX 3D graphics API to create
                a generalized entity base class. The class enables the coupling of transforms between the rendered mesh and its physical representation. Other utilized libraries also inlcude a Simple Shader wrapper class written by <a href="https://github.com/vixorien/SimpleShader">Chris Cascioli(vixorien)</a>
                to manage buffer binding and management. 
            </p>
            <br>
            <pre>
                <code>
#include "Entity.h"
#include "BufferStructs.h"
#include "Camera.h"
#include &lt;cmath&gt;


// Constructor/Destructor
Entity::Entity(Mesh* mesh, Material* material, rp3d::PhysicsWorld* physicsWorld, rp3d::BodyType bodyType)
{
	// Create the rigidbody and configure physics
	entityTransform = new Transform();
	rp3d::Transform rpTransform = ToRp3dTransform(*GetTransform());
	rb = physicsWorld->createRigidBody(rpTransform);
	rb->setType(bodyType);
	previousRbTransform = rpTransform;
	
	// Setup mesh/rendering
	entityMesh = mesh;
	this->material = material;
}

Entity::~Entity()
{
	// Cleanup memory
	delete entityTransform;
	entityTransform = nullptr;
}


Mesh* Entity::GetMesh()
{
	return entityMesh;
}

Material* Entity::GetMaterial()
{
	return material;
}

Transform* Entity::GetTransform()
{
	return entityTransform;
}

rp3d::RigidBody* Entity::GetRigidBody()
{
	return rb;
}

void Entity::MatchRigidbodyTransform(float deltaTime,bool shouldInterpolate)
{
	Transform rbTransformConverted = FromRp3dTransform(rb->getTransform());

	if (shouldInterpolate)
	{
		// Lerp the position of the mesh towards the position of the rotated object to provide smoother motion
		DirectX::XMVECTOR interpolatedVector = DirectX::XMVectorLerp(
			DirectX::XMLoadFloat3(&GetTransform()->GetPosition()),
			DirectX::XMLoadFloat3(&rbTransformConverted.GetPosition()), deltaTime * 30);

		DirectX::XMFLOAT3 lerpedPos;
		DirectX::XMStoreFloat3(&lerpedPos, interpolatedVector);
		entityTransform->SetPosition(lerpedPos.x, lerpedPos.y, lerpedPos.z);

		// Interpolate rotation quaterions to provide smoother rotation (slerp)
		DirectX::XMVECTOR interpolatedRot = DirectX::XMQuaternionSlerp(
			DirectX::XMLoadFloat4(&entityTransform->GetRotation()),
			DirectX::XMLoadFloat4(&rbTransformConverted.GetRotation()),
			deltaTime * 20.0f);
		DirectX::XMFLOAT4 slerpedRotation;
		DirectX::XMStoreFloat4(&slerpedRotation, interpolatedRot);

		// Set the actual rotation
		entityTransform->SetRotationQuat(slerpedRotation);
	}
	else
	{
		entityTransform->SetPosition(rbTransformConverted.GetPosition().x, rbTransformConverted.GetPosition().y, rbTransformConverted.GetPosition().z);
		entityTransform->SetRotationQuat(rbTransformConverted.GetRotation());
	}
	
}

void Entity::UpdateEntityPhysics(float timeStep,float deltaTime,bool shouldInterpolate)
{
	rp3d::Transform currentTransform = rb->getTransform();
	rp3d::Transform interpolated = rp3d::Transform::interpolateTransforms(previousRbTransform, currentTransform, timeStep);
	rb->setTransform(interpolated);

	previousRbTransform = currentTransform;
	MatchRigidbodyTransform(deltaTime,shouldInterpolate);

}

void Entity::AddColliderToRigidBody(rp3d::CollisionShape* collisionShape, rp3d::Transform relativeTransform, float bounciness, float friction)
{
	rp3d::Collider* newCol = rb->addCollider(collisionShape, relativeTransform);
	rp3d::Material& colMat = newCol->getMaterial();

	// Clamp friction between 0 and 1
	friction = friction > 1.0f ? 1.0f : friction < 0.0f ? 0.0f : friction;
	colMat.setBounciness(bounciness);
	colMat.setFrictionCoefficient(friction);
	colMat.setRollingResistance(0.1f);


}

void Entity::SetShaderData(Camera* camera)
{
	// Update the transform to match the rigidbody transform

	// Activate the shaders using simple shader
	material->GetVertexShader()->SetShader();
	material->GetPixelShader()->SetShader();

	// Set samplers and srvs for texture data
	material->SetTextureData();

	// Fill in external data buffer with SimpleShader
	SimpleVertexShader* vs = material->GetVertexShader();
	vs->SetFloat4("color", material->GetColorTint());
	vs->SetMatrix4x4("world", entityTransform->GetWorldMatrix());
	vs->SetMatrix4x4("projectionMatrix", camera->GetProjectionMatrix());
	vs->SetMatrix4x4("viewMatrix", camera->GetViewMatrix());
	vs->SetMatrix4x4("worldInvTranspose", entityTransform->GetWorldInverseTransposeMatrix());
	vs->SetFloat2("uvScale", material->GetUVScale());


	// Fill in external data in the pixel shader
	SimplePixelShader* ps = material->GetPixelShader();
	ps->SetFloat4("colorTint", material->GetColorTint());
	ps->SetFloat("roughness", material->GetRoughness());
	ps->SetFloat3("cameraPosition", camera->GetPosition());

	// Copy data to shaders
	ps->CopyAllBufferData();
	vs->CopyAllBufferData();

}

// Convert Transform class to an rp3d transform
rp3d::Transform Entity::ToRp3dTransform(Transform newTransform)
{
	rp3d::Vector3 position = rp3d::Vector3(newTransform.GetPosition().x, newTransform.GetPosition().y, newTransform.GetPosition().z);
	DirectX::XMFLOAT4 rotationQuat = newTransform.GetRotation();
	rp3d::Quaternion rpQuat = rp3d::Quaternion(rotationQuat.x, rotationQuat.y, rotationQuat.z, rotationQuat.w);

	return rp3d::Transform(position, rpQuat);
}

// Convert rp3d transform to transform
Transform Entity::FromRp3dTransform(rp3d::Transform rpTransform)
{
	DirectX::XMFLOAT3 position = DirectX::XMFLOAT3(rpTransform.getPosition().x, rpTransform.getPosition().y, rpTransform.getPosition().z);
	DirectX::XMFLOAT4 rotationQuat = DirectX::XMFLOAT4(rpTransform.getOrientation().x, rpTransform.getOrientation().y, rpTransform.getOrientation().z, rpTransform.getOrientation().w);
	return Transform(position,rotationQuat,DirectX::XMFLOAT3(1,1,1));
}

// Set correct buffers and draw the object
void Entity::Draw(Microsoft::WRL::ComPtr&lt;ID3D11DeviceContext&gt; deviceContext,Camera* camera)
{
	SetShaderData(camera);
	// Set buffers in the input assembler
	//  - Do this ONCE PER OBJECT drawn, since each object might
	//    have different geometry.
	UINT stride = sizeof(Vertex);
	UINT offset = 0;
	

	deviceContext->IASetVertexBuffers(0, 1, entityMesh->GetVertexBuffer().GetAddressOf(), &stride, &offset);
	deviceContext->IASetIndexBuffer(entityMesh->GetIndexBuffer().Get(), DXGI_FORMAT_R32_UINT, 0);

	// Draw the actual object :)
	deviceContext->DrawIndexed(entityMesh->GetIndexCount(), 0, 0);
}
                </code>
            </pre>
        </div>
        <br>
        <br>
        <h3 class="is-size-3">C#</h3>
        <div class="section" id="csharp-code">
            <p>
                The class below is a third person camera system I created for a small adventure game. The camera rotates around the target object and avoids clipping through
                walls by utilizing a raycast with a custom collision layer mask.
            </p>
            <br>
            <pre>
                <code>
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class CameraController : MonoBehaviour
{
    //References
    [SerializeField] Rigidbody playerRb;
    PlayerMovement playerObject;
    public Camera characterCamera;
    //Vector3 mousePosition;

    //Fields
    float deltaAccleration = 0;
    float fallTimer = 2.0f;
    [SerializeField] float movementSpeed = 100f;    //Higher values = more responsive

    private float lastMousePosition;
    private Vector3 defaultCamera;
    private Quaternion defaultRotation;

    float camXRot;
    public LayerMask camColMask;
    [Header("Camera Parameters")]
    public float cameraDistance;
    public float maxDistance;
    public Vector2 verticalClamp;
    RaycastHit camHit;


    void Start()
    {
        playerObject = playerRb.gameObject.GetComponent&lt;PlayerMovement>();
        defaultRotation = transform.rotation;
        defaultCamera = transform.position;
    }

    // Update is called once per frame
    void Update()
    {

        float minFOV = 60f;
        float maxFOV = 80f;
        float FOVmultiplier = 20;

        float yAcceleration = playerRb.velocity.y * Time.deltaTime;
        yAcceleration = Mathf.Abs(yAcceleration);
        deltaAccleration = yAcceleration - deltaAccleration;

        //Dynamically update FOV
        if (playerObject.IsGrounded())
        {
            fallTimer = 2.0f;
            characterCamera.fieldOfView -= 0.05f;
        }
        if (deltaAccleration <= 0 && fallTimer <= 0)
        {
            characterCamera.fieldOfView -= 0.05f;
        }
        else
        {
            characterCamera.fieldOfView += yAcceleration * FOVmultiplier;
        }

        //Set camera fov
        characterCamera.fieldOfView = Mathf.Clamp(characterCamera.fieldOfView, minFOV, maxFOV);


        if (playerObject.IsFalling())
        {
            fallTimer -= Time.deltaTime * 900;
        }

        //Match player position
        transform.position = Vector3.Lerp(transform.position, playerObject.transform.position, Time.deltaTime * movementSpeed);
        RotateCamera();
    }


    private void FixedUpdate()
    {
        //Prevent camera from clipping with level geometry
        Vector3 dirToCam = characterCamera.transform.position - transform.position;

        //Default to max distance
        Vector3 targetPos = transform.position + dirToCam.normalized * maxDistance;

        if(Physics.Raycast(transform.position,dirToCam,out camHit,maxDistance, camColMask))
        {
            if(!camHit.collider.CompareTag("FlavorCOL") && !camHit.collider.CompareTag("SugarCOL"))
            {
                Vector3 hitPos = camHit.point;
                hitPos += dirToCam.normalized * 0.75f;

                if (Vector3.Distance(hitPos, transform.position) >= 1f)
                {
                    targetPos = hitPos;
                }
            }
         
        }

        characterCamera.transform.position = Vector3.Lerp(characterCamera.transform.position, targetPos, Time.deltaTime * 15.0f);
    }
    private void RotateCamera()
    {
        
        float offSet = 0;
        float offSetSensitivity = 1000;
        if (Input.GetMouseButtonDown(0))
        {
            lastMousePosition = Input.GetAxis("Mouse X");
        }
        if (Input.GetMouseButton(0))
        {
            offSet = Input.GetAxis("Mouse X") - lastMousePosition;
        }
        offSet = offSet*offSetSensitivity;
        float absOffSet = Mathf.Abs(offSet);

        // Reset camera
        if (Input.GetKeyDown(KeyCode.R))
        {
            transform.rotation = defaultRotation;
            transform.position = defaultCamera;
        }

        transform.RotateAround(transform.position, Vector3.up, Time.deltaTime * offSetSensitivity * Input.GetAxis("Mouse X"));

        camXRot -= Time.deltaTime * offSetSensitivity * Input.GetAxis("Mouse Y");
        camXRot = Mathf.Clamp(camXRot, verticalClamp.x, verticalClamp.y);
        transform.eulerAngles = new Vector3(camXRot, transform.eulerAngles.y, transform.eulerAngles.z);
    }

                </code>
            </pre>
        </div>
        <br>
        <br>
        <h3 class="is-size-3">GD Script</h3>
        <div class="section" id="gdscript-code">
            <p>
                The code below is a script I created to allow artists to configure the bone of a 3D skeleton to look at a target object. The resulting transforms can be
                configured to be added on top of the currently playing animation, allowing for dynamic additive animations to be applied to a skeleton.
            </p>
            <br>
            <pre>
                <code>
extends Spatial
class_name BoneLook

enum LOOK_AXIS {AXIS_X,AXIS_Y,AXIS_Z}


export var enabled = false

# The path to the skeleton we want to modify
export var skeleton_path:NodePath

# The name of the bone to modify
export var target_bone_name:String

# The path to the target (name of the target if in SceneResources)
export var target_path:String = ""

export(LOOK_AXIS) var look_axis

export var invert_look_direction:bool = false

# Use rotations on each axis
export var rotate_x:bool = true
export var rotate_y:bool = true
export var rotate_z:bool = true

# Rotational limits around each axis
export var limit_x:Vector2 = Vector2.ZERO
export var limit_y:Vector2 = Vector2.ZERO
export var limit_z:Vector2 = Vector2.ZERO

export(Vector3) var local_offset

export var use_rotation_interpolation:bool = true
export var rotation_speed = 10.0

var target_node

var is_exiting = false

# How much the IK look effects the final rotation of the bone (0.0-1.0)
var current_bone_look_weight:float = 1.0

onready var skeleton:Skeleton = get_node(skeleton_path)
var target_bone_id

var smoothing_tween:Tween

func _ready():
	target_bone_id = skeleton.find_bone(target_bone_name)
	pass

# Smoothly return to animation position
func SmoothExit(duration:float=1.0, transition_type=Tween.EASE_IN_OUT, easing_type=Tween.TRANS_LINEAR,delay=0.0):
	InterpolateCustomPoseWeight(current_bone_look_weight,0.0,transition_type,easing_type,duration,delay)
	#print("Starting exit")
	#print_stack()
	enabled=true
	is_exiting = true
	pass

# Smoothly start the IK for this bone
func SmoothEnable(duration:float=1.0, transition_type=Tween.EASE_IN_OUT, easing_type=Tween.TRANS_LINEAR,delay=0.0):
	enabled = true
	is_exiting = false
	# Prevent triggering guard case on next update
	current_bone_look_weight = 0.001
	InterpolateCustomPoseWeight(current_bone_look_weight,1.0,transition_type,easing_type,duration,delay)
	pass

func SetEnabled(is_enabled):
	# Prevent from disabling automatically
	if is_instance_valid(smoothing_tween):
		var _stopped = smoothing_tween.stop_all()
		pass
	current_bone_look_weight = 1.0
	is_exiting = false
	enabled = is_enabled
	pass

func GetIsEnabled():
	return enabled
	pass

func _process(_delta):
	# No-op if not enabled
	if(!enabled || skeleton == null):
		return

	# No-op if there is no target or it is invalid, or if the look effect weight is 0
	if((target_path == "" || !is_instance_valid(target_node) && !is_exiting) || (is_exiting && current_bone_look_weight <=0.001)):
		enabled = false
		#print("target path is null")
		if is_exiting:
			is_exiting = false
			pass
		return

	# If we're exiting, only move towards zero even if there is no target (reset to animation position)
	if is_exiting:
		var bone_transform = skeleton.get_bone_custom_pose(target_bone_id)
		var new_transform = Transform.IDENTITY.interpolate_with(bone_transform,current_bone_look_weight)
		skeleton.set_bone_custom_pose(target_bone_id,new_transform)
		return

	LookAtTarget(target_node.global_transform.origin)

	pass

# Update the target we want to look at
func UpdateTarget(var new_target_path,enable_after_update=true):
	enabled = false
	target_path = new_target_path
	target_node = get_node(target_path)

	if enable_after_update:
		SetEnabled(true)
		pass
	pass

# Interpolate the bone look weight between start_weight and end_weight over duration
func InterpolateCustomPoseWeight(start_weight:float,end_weight:float,transition_type,easing_type, duration:float=1.0,delay = 0.0):

	# Add or stop the tween
	if !is_instance_valid(smoothing_tween):
		smoothing_tween = Tween.new()
		add_child(smoothing_tween)
		pass
	elif smoothing_tween.is_active():
		var _stop = smoothing_tween.stop(self,"current_bone_look_weight")
		pass

	# Start the interpolation
	var _t = smoothing_tween.interpolate_property(self,"current_bone_look_weight",start_weight,end_weight,duration,transition_type,easing_type,delay)
	_t = smoothing_tween.start()

	pass

# Rotate bone to look towards a target object
func LookAtTarget(var target_global_pos:Vector3):

	# Bail if skeleton is not initalized
	if(skeleton == null):
		return

	# We aren't rotating on any axis, why bother
	if !rotate_x && !rotate_y && !rotate_z:
		enabled = false
		return


	# Convert target location to local space relative to the skeleton
	var target_local = skeleton.global_transform.xform_inv(target_global_pos) + local_offset
	
	var bone_transform = skeleton.get_bone_custom_pose(target_bone_id)
	var target_transform = bone_transform

	# Invert direction if needed
	if invert_look_direction:
		target_local = -target_local
		pass

	# Set the look at axis
	if look_axis == LOOK_AXIS.AXIS_X:
		#print("X")
		target_transform = target_transform.looking_at(target_local,Vector3.RIGHT)
		pass
	elif look_axis == LOOK_AXIS.AXIS_Y:
		#print("Y")
		target_transform = target_transform.looking_at(target_local,Vector3.UP)
		pass
	elif look_axis == LOOK_AXIS.AXIS_Z:
		#print("Z")
		target_transform = target_transform.looking_at(target_local,Vector3.FORWARD)
		pass

	var target_transform_euler = target_transform.basis.get_euler()


	# Apply rotations
	# ======================== X ========================
	if !rotate_x:
		target_transform_euler.x = bone_transform.basis.get_euler().x
		pass

	# # ======================== Y ========================
	if !rotate_y:
		target_transform_euler.y = bone_transform.basis.get_euler().y

	# ======================== Z ========================
	if !rotate_z:
		target_transform_euler.z = bone_transform.basis.get_euler().z
		pass


	# Apply limitations
	if limit_x != Vector2.ZERO:
		target_transform_euler.x = clamp(target_transform_euler.x, deg2rad(limit_x.x), deg2rad(limit_x.y))
		pass
	if limit_y != Vector2.ZERO:
		target_transform_euler.y = clamp(target_transform_euler.y, deg2rad(limit_y.x), deg2rad(limit_y.y))
		pass
	if limit_z != Vector2.ZERO:
		target_transform_euler.z = clamp(target_transform_euler.z, deg2rad(limit_z.x), deg2rad(limit_z.y))
		pass
		

	# Create new basis from modified rotations
	target_transform.basis = Basis(target_transform_euler)


	var new_transform = target_transform

	# Interpolate between positions if needed
	if use_rotation_interpolation:
		new_transform = bone_transform.interpolate_with(target_transform,get_process_delta_time() * rotation_speed)
		pass

	# Apply weight to bone pos, with a 0.0 bone weight essentially nullifying any custom pose
	new_transform = Transform.IDENTITY.interpolate_with(new_transform,current_bone_look_weight)

	# Apply new rotation to the bone custom poss
	skeleton.set_bone_custom_pose(target_bone_id,new_transform)
	pass

                </code>
            </pre>
        </div>
    </main>
    <footer class="has-text-centered"> ©2021 Ethan Ruhl. All rights reserved</footer>
    <br>
</body>
</html>